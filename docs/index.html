<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Notion-like Editor (Dark Theme)</title>
  <link href='https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css' rel='stylesheet'>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/default.min.css">
  <style>
    body {
      background-color: #242424; /* Dark background */
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
      color: #e0e0e0; /* Light text color */
    }
    #editor {
      margin: 50px auto;
      width: 80%;
      max-width: 800px;
      padding: 20px;
      border-radius: 8px;
      background-color: #1a1a1a; /* Darker background for editor */
      border: 1px solid #333;
      font-size: 1.15rem;
      outline: none;
      min-height: 500px;
      line-height: 1.6;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      caret-color: #f0f0f0; /* White caret */
    }
    #editor:empty::before {
      content: "Start typing...";
      color: #888;
    }

    /* Notion-like Dark Theme Typography */
    h1 { color: #f0f0f0; font-size: 2.5em; font-weight: 700; margin: 0.8em 0 0.4em; }
    h2 { color: #f0f0f0; font-size: 2em; font-weight: 700; margin: 0.8em 0 0.4em; }
    h3 { color: #f0f0f0; font-size: 1.5em; font-weight: 700; margin: 0.8em 0 0.4em; }
    h4 { color: #f0f0f0; font-size: 1.2em; font-weight: 700; margin: 0.8em 0 0.4em; }
    h5 { color: #f0f0f0; font-size: 1.1em; font-weight: 700; margin: 0.8em 0 0.4em; }
    h6 { color: #f0f0f0; font-size: 1em; font-weight: 700; margin: 0.8em 0 0.4em; }

    blockquote {
      border-left: 4px solid #4a4a4a;
      padding-left: 15px;
      margin: 1em 0;
      color: #b0b0b0;
      font-style: italic;
    }
    ul, ol {
      margin-left: 25px;
      padding-left: 0;
    }
    li {
      margin-bottom: 0.2em;
    }
    li > ul, li > ol {
      margin-left: 20px;
      margin-top: 0;
      margin-bottom: 0;
    }
    hr {
      border: none;
      border-top: 1px solid #444;
      margin: 20px 0;
      box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
    }
    pre {
      background-color: #282c34; /* Atom One Dark background */
      padding: 15px;
      border-radius: 8px;
      overflow-x: auto;
      font-family: 'Fira Code', 'JetBrains Mono', monospace; /* Monospaced font */
      font-size: 0.9em;
      margin: 1em 0;
      color: #abb2bf; /* Default text color in Atom One Dark */
      line-height: 1.45;
      position: relative; /* For copy button positioning */
    }
    pre .copy-button {
      position: absolute;
      top: 8px;
      right: 8px;
      background-color: #3a3a3a;
      border: none;
      border-radius: 4px;
      color: #ccc;
      cursor: pointer;
      padding: 6px;
      font-size: 1.1em;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background-color 0.2s, color 0.2s;
      opacity: 0; /* Hidden by default */
    }
    pre:hover .copy-button {
      opacity: 1; /* Show on hover */
    }
    pre .copy-button:hover {
      background-color: #555;
      color: #fff;
    }
    pre code {
      background: none;
      padding: 0;
      border-radius: 0;
      color: inherit;
      font-size: inherit;
      display: block; /* Make code fill pre */
      white-space: pre-wrap; /* Preserve whitespace and wrap */
    }
    code {
      background-color: #3a3a3a; /* Darker background for inline code */
      padding: 0.2em 0.4em;
      border-radius: 4px;
      font-family: 'Fira Code', 'JetBrains Mono', monospace;
      font-size: 0.85em;
      color: #e38a8a; /* Reddish for inline code */
    }
    b, strong { font-weight: bold; color: #f0f0f0; }
    i, em { font-style: italic; color: #c0c0c0; }
    u { text-decoration: underline; color: #9090f0; }
    s { text-decoration: line-through; color: #a0a0a0; }
    mark { background-color: #4a4a20; color: #ffe082; padding: 0.2em 0.4em; border-radius: 3px; } /* Yellowish highlight */
  </style>
</head>
<body>

<div id="editor" contenteditable="true" spellcheck="false"><div><br></div></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>

<!-- Explicit language support -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/javascript.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/python.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/xml.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/htmlbars.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/css.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/bash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/json.min.js"></script>
<script>
  // Dynamically load common languages for highlight.js
  // For a production app, you might want to only load languages you expect
  hljs.highlightAll(); // Initialize highlight.js on initial load

  const editor = document.getElementById('editor');

  function highlightCodeBlock(codeElement) {
    if (!codeElement) return;
    try {
      hljs.highlightElement(codeElement);
    } catch (error) {
      console.warn("Highlight.js error:", error);
    }
  }

  function getCurrentLineElement() {
    const sel = window.getSelection();
    if (!sel.rangeCount) return null;

    let node = sel.getRangeAt(0).startContainer;

    while (node && node !== editor) {
      // Return the direct child of #editor
      if (node.parentNode === editor) {
          return node;
      }
      // If we are inside a list item, return the LI
      if (node.tagName === 'LI') {
          return node;
      }
      // If we are inside a PRE (code block), return the PRE
      if (node.tagName === 'PRE') {
          return node;
      }
      node = node.parentNode;
    }
    return null;
  }

  function placeCaretAtStart(el) {
    const range = document.createRange();
    const sel = window.getSelection();

    if (el.nodeType === Node.TEXT_NODE) {
        range.setStart(el, 0);
    } else if (el.firstChild) {
        if (el.firstChild.nodeType === Node.TEXT_NODE) {
            range.setStart(el.firstChild, 0);
        } else {
            range.setStartBefore(el.firstChild);
        }
    } else {
        range.setStart(el, 0);
    }
    range.collapse(true);
    sel.removeAllRanges();
    sel.addRange(range);
  }

  function placeCaretAtEnd(el) {
    const range = document.createRange();
    const sel = window.getSelection();
    range.selectNodeContents(el);
    range.collapse(false);
    sel.removeAllRanges();
    sel.addRange(range);
  }

  function createNewLineElement() {
    const div = document.createElement('div');
    div.appendChild(document.createElement('br'));
    return div;
  }

  function replaceLine(oldLineEl, newEl, placeCaretStrategy = 'end', caretOffset = 0, currentRange = null) {
    const parent = oldLineEl.parentNode;
    if (parent) {
      parent.replaceChild(newEl, oldLineEl);
    } else {
      editor.appendChild(newEl);
    }

    // Restore caret
    if (currentRange && currentRange.startContainer) { // Ensure currentRange is valid
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(currentRange);
    } else if (placeCaretStrategy === 'start') {
        placeCaretAtStart(newEl);
    } else if (placeCaretStrategy === 'end') {
        placeCaretAtEnd(newEl);
    } else if (placeCaretStrategy === 'offset') {
        const range = document.createRange();
        const sel = window.getSelection();
        const textNode = newEl.firstChild;
        if (textNode && textNode.nodeType === Node.TEXT_NODE) {
            range.setStart(textNode, Math.min(caretOffset, textNode.length));
        } else if (newEl.childNodes.length > 0) {
            range.setStart(newEl, 0);
        } else {
            range.setStart(newEl, 0);
        }
        range.collapse(true);
        sel.removeAllRanges();
        sel.addRange(range);
    }
  }

  function applyBlockStyle(lineEl, tag, pattern, caretOffset = 0) {
    const text = lineEl.textContent;
    const match = text.match(pattern);
    if (!match) return false;

    const newEl = document.createElement(tag);
    newEl.textContent = match[1] || '\u200B';

    // Save current range to restore later if needed, especially for inline changes
    const sel = window.getSelection();
    const currentRange = sel.rangeCount > 0 ? sel.getRangeAt(0).cloneRange() : null;

    replaceLine(lineEl, newEl, 'offset', caretOffset, currentRange);
    return true;
  }

  function handleBlockFormatting(lineEl) {
    const text = lineEl.textContent;
    let handled = false;

    // Ordered by specificity.
    // Ensure transformations only happen on a default DIV, not already styled blocks.
    if (lineEl.tagName === 'DIV') {
        // Code Block
        if (text.trim() === '```') {
  const pre = document.createElement('pre');
  pre.style.border = '2px solid #666';
  pre.style.position = 'relative';

  const code = document.createElement('code');
  code.innerHTML = ''; // No backtick
  pre.appendChild(code);

  const copyButton = document.createElement('button');
  copyButton.className = 'copy-button';
  copyButton.style.position = 'absolute';
  copyButton.style.top = '8px';
  copyButton.style.left = '8px';
  copyButton.innerHTML = "<i class='bx bx-copy'></i>";
  copyButton.onclick = (e) => {
    e.stopPropagation();
    navigator.clipboard.writeText(code.textContent);
    const originalIcon = copyButton.innerHTML;
    copyButton.innerHTML = "<i class='bx bx-check'></i>";
    setTimeout(() => copyButton.innerHTML = originalIcon, 1500);
  };
  pre.appendChild(copyButton);

  replaceLine(lineEl, pre, 'end');
  placeCaretAtEnd(code);
  return true;
}

        // Horizontal Rule
        if (text.trim() === '---' || text.trim() === '***' || text.trim() === '___') {
            const hr = document.createElement('hr');
            replaceLine(lineEl, hr, 'none');
            const newDiv = createNewLineElement();
            editor.insertBefore(newDiv, hr.nextSibling);
            placeCaretAtStart(newDiv);
            return true;
        }

        // Headings
        if (applyBlockStyle(lineEl, 'h1', /^#\s(.*)/, 0)) handled = true;
        else if (applyBlockStyle(lineEl, 'h2', /^##\s(.*)/, 0)) handled = true;
        else if (applyBlockStyle(lineEl, 'h3', /^###\s(.*)/, 0)) handled = true;
        else if (applyBlockStyle(lineEl, 'h4', /^####\s(.*)/, 0)) handled = true;
        else if (applyBlockStyle(lineEl, 'h5', /^#####\s(.*)/, 0)) handled = true;
        else if (applyBlockStyle(lineEl, 'h6', /^######\s(.*)/, 0)) handled = true;
        else if (applyBlockStyle(lineEl, 'blockquote', /^>\s(.*)/, 0)) handled = true;
        if ((text.startsWith('* ') || text.startsWith('- ')) && lineEl.tagName === 'DIV') {
        const ul = document.createElement('ul');
        const li = document.createElement('li');
        li.textContent = text.substring(2) || '\u200B';
        ul.appendChild(li);
        replaceLine(lineEl, ul, 'none');
        placeCaretAtEnd(li);
        handled = true;
    }
        else if (text.match(/^(\d+)\.\s(.*)/)) {
            const olMatch = text.match(/^(\d+)\.\s(.*)/);
            const ol = document.createElement('ol');
            const li = document.createElement('li');
            li.textContent = olMatch[2] || '\u200B';
            li.setAttribute('value', parseInt(olMatch[1]));
            ol.appendChild(li);
            replaceLine(lineEl, ol, 'none');
            placeCaretAtEnd(li);
            handled = true;
        }
    }

    return handled;
  }

  const inlineStyles = [
  { regex: /(?<!\\)(\*\*|__)(.+?)\1/g, tag: 'strong' },  // **bold**, __bold__
  { regex: /(?<!\\)(\*|_)(.+?)\1/g, tag: 'em' },         // *italic*, _italic_
  { regex: /(?<!\\)(~~)(.+?)\1/g, tag: 's' },            // ~~strikethrough~~
  { regex: /(?<!\\)(==)(.+?)\1/g, tag: 'mark' },         // ==highlight==
  { regex: /(?<!\\)(`)(?!``)(.+?)\1/g, tag: 'code' },    // `inline code` (not triple)
  { regex: /(?<!\\)(__)(.+?)(__)/g, tag: 'u' },          // __underline__ (only if not caught by bold)
];

  function escapeHtml(unsafe) {
    return unsafe
      .replace(/&/g, "&")
      .replace(/</g, "<")
      .replace(/>/g, ">")
      .replace(/"/g, '"')
      .replace(/'/g, "'");
  }

  function applyInlineStylesToTextNode(textNode, savedRange) {
      if (!textNode || textNode.nodeType !== Node.TEXT_NODE || textNode.parentNode.tagName === 'CODE' || textNode.parentNode.tagName === 'PRE') {
          return;
      }

      let originalText = textNode.nodeValue;
      let newHtml = originalText;
      let changed = false;

      for (const style of inlineStyles) {
          newHtml = newHtml.replace(style.regex, (match, p1, p2) => {
              const content = (style.tag === 'code') ? escapeHtml(p2) : p2;
              changed = true;
              return `<${style.tag}>${content}</${style.tag}>`;
          });
      }

      if (changed) {
      const tempSpan = document.createElement('span');
      tempSpan.innerHTML = newHtml;

      const parent = textNode.parentNode;
      const fragment = document.createDocumentFragment();
      while (tempSpan.firstChild) {
          fragment.appendChild(tempSpan.firstChild);
      }
      parent.replaceChild(fragment, textNode);

      // Restore caret position 
      if (savedRange) {
          const sel = window.getSelection();
          sel.removeAllRanges();
          sel.addRange(savedRange);
      }

      Array.from(parent.childNodes).forEach(child => {
          if (child.nodeType === Node.TEXT_NODE) {
              applyInlineStylesToTextNode(child, savedRange);
          } else if (child.nodeType === Node.ELEMENT_NODE && child.tagName !== 'CODE' && child.tagName !== 'PRE') {
              traverseAndApplyInlineStyles(child, savedRange);
          }
      });
  }
  }

  function traverseAndApplyInlineStyles(node, savedRange) {
      if (!node) return;
      if (node.nodeType === Node.TEXT_NODE) {
          applyInlineStylesToTextNode(node, savedRange);
      } else if (node.nodeType === Node.ELEMENT_NODE && node.tagName !== 'CODE' && node.tagName !== 'PRE') {
          Array.from(node.childNodes).forEach(child => {
              traverseAndApplyInlineStyles(child, savedRange);
          });
      }
  }

  editor.addEventListener('input', (e) => {
    const sel = window.getSelection();
    const range = sel.rangeCount > 0 ? sel.getRangeAt(0) : null;
    const currentLine = getCurrentLineElement();

    if (!currentLine || !range) return;

    // Save current caret position before DOM changes
    const savedRange = range.cloneRange();

    // Block formatting triggered by typing specific patterns + space or Enter
    if (e.inputType === 'insertText' && e.data === ' ') {
        if (handleBlockFormatting(currentLine)) {
            return;
        }
    }

    // Apply inline styles if not in a PRE block
    if (currentLine.tagName !== 'PRE') {
        traverseAndApplyInlineStyles(currentLine, savedRange);
    } else {
        const codeEl = currentLine.querySelector('code');
        if (codeEl) {
            highlightCodeBlock(codeEl);
        }
    }

    // Restore caret position after DOM changes
    try {
        sel.removeAllRanges();
        sel.addRange(savedRange);
    } catch (err) {
        // Fallback if savedRange becomes invalid, try to place at end of current line
        placeCaretAtEnd(currentLine);
    }
  });

  let enterPressCount = 0;
  editor.addEventListener('keydown', (e) => {
    const sel = window.getSelection();
    const range = sel.rangeCount > 0 ? sel.getRangeAt(0) : null;
    const currentLine = getCurrentLineElement();

    if (e.key === 'Enter') {
      e.preventDefault();
      enterPressCount++;

      if (!currentLine) { // Should not happen with initial setup
        editor.appendChild(createNewLineElement());
        placeCaretAtStart(editor.lastChild);
        return;
      }

      if (currentLine.tagName === 'LI') {
        const parentList = currentLine.parentNode;
        if (currentLine.textContent.trim() === '' && !currentLine.querySelector('ul, ol')) {
          if (enterPressCount >= 2) { // Double enter to exit list
            const newDiv = createNewLineElement();
            parentList.removeChild(currentLine);
            if (parentList.children.length === 0) { // Remove empty parent list
              parentList.remove();
            }
            editor.insertBefore(newDiv, parentList.nextSibling || null);
            placeCaretAtStart(newDiv);
            enterPressCount = 0; // Reset count
          } else {
            // Single enter on empty LI, do nothing (wait for double enter)
            // Or, simply create a new LI if it was an empty LI to begin with
            const newLi = document.createElement('li');
            newLi.appendChild(document.createElement('br'));
            currentLine.parentNode.insertBefore(newLi, currentLine.nextSibling);
            placeCaretAtStart(newLi);
          }
        } else {
          // Create new LI and move content after caret to it
          const newLi = document.createElement('li');
          const remainingContents = range.extractContents();
          if (remainingContents.hasChildNodes()) {
              newLi.appendChild(remainingContents);
          } else {
              newLi.appendChild(document.createElement('br'));
          }
          currentLine.parentNode.insertBefore(newLi, currentLine.nextSibling);
          placeCaretAtStart(newLi);
          enterPressCount = 0; // Reset count on contentful LI
        }
      } else if (currentLine.tagName === 'PRE') {
  if (enterPressCount === 2) {
    // Double enter: exit code block
    const newDiv = createNewLineElement();
    editor.insertBefore(newDiv, currentLine.nextSibling);
    placeCaretAtStart(newDiv);
    enterPressCount = 0;
  } else {
    const codeEl = currentLine.querySelector('code');
    if (codeEl) {
      const range = sel.getRangeAt(0);
      const textNode = document.createTextNode('\n');
      range.insertNode(textNode);
      range.setStartAfter(textNode);
      range.setEndAfter(textNode);
      sel.removeAllRanges();
      sel.addRange(range);
      highlightCodeBlock(codeEl);
    }
  }
} else {
        // For other block elements, break the current style and go to default div
        const newDiv = createNewLineElement();
        const remainingContents = range.extractContents();
        if (remainingContents.hasChildNodes()) {
            newDiv.appendChild(remainingContents);
        }

        editor.insertBefore(newDiv, currentLine.nextSibling);
        placeCaretAtStart(newDiv);
        enterPressCount = 0; // Reset count
      }
    } else if (e.key === 'Tab') {
      e.preventDefault();
      if (currentLine && currentLine.tagName === 'LI') {
        const parentList = currentLine.parentNode;
        const previousSibling = currentLine.previousElementSibling;

        if (previousSibling && previousSibling.tagName === 'LI') {
          let nestedList;
          if (previousSibling.lastElementChild && (previousSibling.lastElementChild.tagName === 'UL' || previousSibling.lastElementChild.tagName === 'OL')) {
            nestedList = previousSibling.lastElementChild;
          } else {
            nestedList = document.createElement(parentList.tagName);
            previousSibling.appendChild(nestedList);
          }
          nestedList.appendChild(currentLine);
          placeCaretAtEnd(currentLine);
        }
      } else {
          const spaceNode = document.createTextNode('  ');
          range.insertNode(spaceNode);
          range.collapse(false);
          sel.removeAllRanges();
          sel.addRange(range);
      }
    } else if (e.key === 'Backspace') {
        enterPressCount = 0; // Reset on backspace
        const sel = window.getSelection();
        if (sel.isCollapsed && sel.anchorOffset === 0) {
            const currentLine = getCurrentLineElement();
            if (!currentLine) return;

            if (currentLine.tagName !== 'DIV' && currentLine.tagName !== 'LI' && currentLine.tagName !== 'PRE') {
                e.preventDefault();
                const newDiv = createNewLineElement();
                newDiv.innerHTML = currentLine.innerHTML;
                const prevSibling = currentLine.previousElementSibling;

                editor.replaceChild(newDiv, currentLine);
                if (prevSibling) {
                    placeCaretAtEnd(prevSibling);
                } else {
                    placeCaretAtStart(newDiv);
                }
            } else if (currentLine.tagName === 'LI' && !currentLine.previousElementSibling && currentLine.parentNode.parentNode === editor) {
                e.preventDefault();
                const parentList = currentLine.parentNode;
                const newDiv = createNewLineElement();
                newDiv.innerHTML = currentLine.innerHTML;
                parentList.removeChild(currentLine);
                if (parentList.children.length === 0) {
                    parentList.remove();
                }
                editor.insertBefore(newDiv, parentList.nextSibling || parentList);
                placeCaretAtEnd(newDiv);
            }
        }
    } else {
      enterPressCount = 0; // Reset on any other key
    }
  });

  // Handle Shift+Tab for un-indenting lists
  editor.addEventListener('keydown', (e) => {
      if (e.key === 'Tab' && e.shiftKey) {
          e.preventDefault();
          const currentLi = getCurrentLineElement();
          if (currentLi && currentLi.tagName === 'LI') {
              const parentList = currentLi.parentNode;
              const grandParentLi = parentList.parentNode;

              if (grandParentLi && grandParentLi.tagName === 'LI') {
                  grandParentLi.parentNode.insertBefore(currentLi, grandParentLi.nextSibling);
                  if (parentList.children.length === 0) {
                      parentList.remove();
                  }
                  placeCaretAtEnd(currentLi);
              } else if (parentList.parentNode === editor) {
                  const newDiv = document.createElement('div');
                  newDiv.innerHTML = currentLi.innerHTML;
                  editor.insertBefore(newDiv, parentList.nextSibling || parentList);
                  parentList.removeChild(currentLi);
                  if (parentList.children.length === 0) {
                      parentList.remove();
                  }
                  placeCaretAtEnd(newDiv);
              }
          }
      }
  });


  // Initialize editor
  if (editor.children.length === 0 || editor.textContent.trim() === '') {
    editor.appendChild(createNewLineElement());
  }
  if (editor.firstChild && editor.firstChild.firstChild) {
  placeCaretAtStart(editor.firstChild.firstChild);
} else {
  placeCaretAtStart(editor.firstChild);
}
</script>

</body>
</html>